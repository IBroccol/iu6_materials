# C++
#### 1. Основные отношения между классами: наследование, композиция, наполнение, зависимость. Примеры диаграмм классов.
Наследование - создание производных классов на основе базового, класс-наследник получает свойства и методы базового класса, может переопределять и добавлять новые. На диаграмме классов обозначается незакрашенной стрелкой
Композиция - отношение между классами, когда один из них включает в себя объекты другого (1 или больше) и полностью управляет их жизненным циклом. Включаемый объект может существовать только как часть контейнера. Обозначается на диаграмме стрелочкой с закрашенным ромбиком. Пример: автомобиль и двигатель, без которого он не будет работать.
Наполнение(агрегация) - отношение между классами, при котором один из них содержит или не содержит объекты другого (0 или больше), в отличие от композиции объекты второго класса могут существовать без объекта первого. Пример: автомобиль и колёса, которые могут быть в количестве от 0 до 4.
Зависимость(ассоциация) - объекту одного класса ставится в соответствие некоторое количество объектов другого, на диаграмме обозначается простой стрелкой с указанием с каждой стороны количества объектов. В этом случае один класс содержит или использует объекты другого.
#### 2. Конструкторы: инициализирующий, без параметров (инициализирующий и неинициализирующий), копирующий, перемещения. Примеры.
Конструкторы представляют специальную функцию, которая имеет то же имя, что и класс, которая не возвращает никакого значения и которая позволяет инициализировать объект класса во время его создания и таким образом гарантировать, что поля класса будут иметь определенные значения. При каждом создании нового объекта класса вызывается конструктор класса. Конструкторов может быть не сколько, каждый может иметь любые параметры и вызывать другие конструкторы.
По умолчанию компилятор при компиляции классов генерирует специальный конструктор - **конструктор копирования**, который позволяет создать объект на основе другого объекта (по сути копирует объект). Конструктор копирования по умолчанию копирует значения полей объекта, в новый объект. Конструктор копирования должен принимать в качестве параметра объект того же класса. Причем параметр лучше принимать по ссылке, потому что при передаче по значению компилятор будет создавать копию объекта. А для создания копия объекта будет вызываться конструктор копирования, что приведет бесконечной рекурсии.
```cpp
Person(const Person &p)
{
    name = p.name;
    age = p.age + 1;
}
// если нужно удалить копирующий конструктор
cppPerson(const Person &p) = delete;
```
**Конструктор перемещения** (move constructor) представляет альтернативу конструктору копирования в тех ситуациях, когда надо сделать копию объекта, но копирование данных нежелательно - вместо копирования данных они просто перемещаются из одной копии объекта в другую.
```cpp
class Message
{
    public:
    Message(const char* data, unsigned count)
    {
        size = count;
        text = new char[size];  // выделяем память
        for(unsigned i{}; i < size; i++)    // копируем данные
        {
    text[i] = data[i];
}
id = ++counter;
std::cout << "Create Message " << id << std::endl;
    }
    // конструктор копирования
    Message(const Message& copy) : Message{copy.getText(), copy.size }  // обращаемся к стандартному конструктору
    {
    std::cout << "Copy  Message " << copy.id << " to " << id << std::endl;
}
    ~Message() // деструктор
    {
        std::cout << "Delete Message " << id << std::endl;
        delete[] text;  // особождаем память
    }
    char* getText() const { return text; }
    unsigned getSize() const { return size; }
    unsigned getId() const {return id;}
private:
    char* text { };  // текст сообщения
    unsigned size { };    // размер сообщения
    unsigned id { };  // номер сообщения
    static inline unsigned counter{};   // статический счетчик для генерации номера объекта
};
```
#### 3. Список инициализации. Примеры.
Поля класса, являющиеся константами нельзя инициализировать в конструкторе, потому что они являются неизменяемыми, поэтому используются списки инициализации:
```cpp
class Person
{
    const std::string name;
    unsigned age;
    public:
    void print()
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
    Person(std::string p_name, unsigned p_age) : name(p_name), age(p_age)
    { }
};
```
В этом случае поля `name` и `age` получат значения параметров `p_name` и `p_age` ещё до того, как начнёт выполняться тело конструктора `Person`. При использовании списков инициализации важно учитывать, что передача значений должна идти в том порядке, в котором константы и переменные определены в классе.
#### 4. Наследование. Особенности описания конструкторов производных классов. Примеры.
Наследование - создание производных классов на основе базового, класс-наследник получает свойства и методы базового класса, может переопределять и добавлять новые.
При наследовании конструкторы **не наследуются**, и если базовый класс содержит только конструкторы с параметрами, то производный класс должен вызывать в своем конструкторе один из конструкторов базового класса. После списка параметров конструктора производного класса через двоеточие идет вызов конструктора базового класса, в который передаются значения параметров.
```cpp
# include <iostream>
class Person
{
public:
    Person(std::string name, unsigned age);
    void print();
private:
    std::string name;
    unsigned age;
};
class Employee : public Person
{
public:
    Employee(std::string name, unsigned age, std::string company): Person(name, age) // вызов конструктора базового класса
    {
        this->company = company;
    }
private:
    std::string company;
};
```
Если конструктор полностью совпадает с конструктором базового класса его можно просто подключить:
```cpp
class Employee : public Person
{
public:
    using Person::Person;
};
```
#### 5. Композиция. Особенности описания конструкторов классов-агрегатов. Примеры.
Композиция - отношение между классами, когда один из них включает в себя объекты другого (1 или больше) и полностью управляет их жизненным циклом. Включаемый объект может существовать только как часть контейнера. Обозначается на диаграмме стрелочкой с закрашенным ромбиком. Пример: автомобиль и двигатель, без которого он не будет работать. Для включаемых классов обязательным условием является существование конструктора по умолчанию.
```cpp
class Point2D
{
private:
    int m_x;
    int m_y;
public:
    // Конструктор по умолчанию
    Point2D() : m_x(0), m_y(0) {}
    // Специфический конструктор
    Point2D(int x, int y) : m_x(x), m_y(y) {}
    void setPoint(int x, int y)
    {
        m_x = x;
        m_y = y;
    }
};
class Line
{
private:
    std::string name;
    Point2D a, b;
}
```
#### 6. Наполнение. Особенности описания конструкторов и деструкторов классов-агрегатов. Примеры.
Наполнение(агрегация) - отношение между классами, при котором один из них содержит или не содержит объекты другого (0 или больше), в отличие от композиции объекты второго класса могут существовать без объекта первого. Пример: автомобиль и колёса, которые могут быть в количестве от 0 до 4.
```cpp
class Wheel {
private:
	int id;
	static int n;
public:
	Wheel() {
		id = ++n;
	}
	int getID() { return id; }
};

int Wheel::n = 0;

class Car {
private:
	Wheel* wheels;
public:
	Car(Wheel* w) : wheels(w) {};
	~Car() {
		std::cout << "Объект Car уничтожается\n";
	}
};

int main()
{
	Wheel* wheels = new Wheel[4]; // массив колёс
	{
		Car car(wheels); // автомобиль с колёсами
	} // объект car удаляется при выходе из блока
	for (int i = 0; i < 4; ++i)
		std::cout << wheels[i].getID() << "\n"; // колёса продолжают существовать
	delete[] wheels;
}
```
#### 7. Полиморфное наследование в языке С++. Раннее и позднее связывание: описание в программе и механизмы реализации. Примеры.
Полиморфизм в языке C++ позволяет работать с разными данными одинаковым образом. Несколько классов наследуют и переопределяют свойства одного общего, в результате чего получают общий интерфейс для работы с ними. В зависимости от способа переопределения происходит раннее или позднее связывание методов с объектами и типами, для которых они будут вызваны.
Раннее связывание - это когда обычный метод явно переопределяется для класса-наследника и вызывается для всех объектов соответствующего типа, в том числе по типу указателя на объект(если явно преобразовать тип указателя, для него будет вызван уже другой метод, независимо от того, объект какого типа реально находится по данному адресу).
Позднее связывание - это когда метод родительского класса объявляется виртуальным и классы-наследники его переопределяют, в этом случае для данной иерархии классов создаётся специальная таблица виртуальных методов и при каждом вызове метода для объекта по указателю происходит получение реального типа хранимого объекта из специального скрытого поля и вызов метода по таблице для него.
В данном примере для метода `PrintInfo()` используется раннее связывание, а для метода `Sound` - позднее связывание:
```cpp
class Animal {
public:
	virtual void Sound()=0; // чистая виртуальная функция, требуется переопределение в потомках
	void PrintInfo() { // обычный метод
		std::cout << "Class Animal\n";
	};
};

class Dog : public Animal {
public:
	void Sound() override {
		std::cout  << "Ruff-ruff\n";
	}
	void PrintInfo() {
		std::cout << "Class Dog\n";
	}
};

class Cat : public Animal {
public:
	void Sound() override {
		std::cout << "Meow-meow\n";
	}
	void PrintInfo() {
		std::cout << "Class Cat\n";
	}
};

int main() {
	Animal *animals[2];
	animals[0] = new Cat();
	animals[1] = new Dog();
	for (auto i : animals) {
		i->Sound();	// для каждого объекта вызовется свой метод
		i->PrintInfo(); // для всех объектов вызовется метода класса Animal
	}
	// при позднем связывании для любого преобразования типа указателя
	// всё равно вызовется метода, соответствующий реальному типу объекта
	((Dog*)animals[0])->Sound();
	((Dog*)animals[1])->Sound();
	// при раннем связывании и явном преобразовании вызовется метод типа указателя
	((Cat*)animals[0])->PrintInfo();
	((Dog*)animals[1])->PrintInfo();
}
```
#### 8. Контейнерные классы. Примеры диаграмм классов.
Для управления наборами объектов в стандартной библиотеке C++ определены контейнеры. Контейнер представляет коллекцию объектов определенного типа и позволяет и управлять доступом к этим элементам. В С++ есть два типа контейнеров: ассоциативные и последовательные:
##### Последовательные
Обеспечивают хранение конечного количества однотипных величин в виде непрерывной последовательности
- **`vector`** - динамический массив - структура, эффективно реализующая произвольный доступ к элементам, добавление в конец и удаление из конца
- **`list`** - линейный список - эффективно реализует вставку и удаление элементов в/из произвольного места и не эффективно - произвольный доступ к элементам
- **`stack`**  - стек - эффективно реализует добавление в конец и удаление из конца
- **`queue`** - очередь - эффективно реализует добавление в конец и удаление из начала
- **`deque`** - двусторонняя очередь (дек) - эффективно реализует произвольный доступ к элементам, добавление в оба конца и удаление из обоих концов
- **`priority_queue`** – очередь, сортированная по приоритетам
##### Ассоциативные
Обеспечивают быстрый доступ к данным по ключу, построены на основе сбалансированных деревьев
- **`map`** - словарь с уникальными ключами
- **`multimap`** - словарь с дубликатами ключей
- **`set`** - множество
- **`multiset`** - мультимножество
- **`bitset`** - битовое множество (набор битов)
#### 9. Qt. Принципы создания графических интерфейсов. Использование С++ контейнеров.

#### 10. Qt. Сигналы и слоты.
Механизм сигналов и слотов представляет одну из отличительных особенностей Qt и позволяют сделать приложение отзывачивым, реагировать на действия пользователя, отслеживать различные события в приложении. Так, когда пользователь выполняет какое-либо действие с каким-либо элементом пользовательского интерфейса, должна быть выполнена определенная задача. Например, если пользователь нажимает кнопку "Закрыть" в верхнем правом углу окна, то ожидается, что окно закроется. То есть необходим механизм для отслеживания событий и реагирования на них. В среде Qt такой механизм предоставляют сигналы и слоты.
- **Сигнал** - это сообщение, которое передается, чтобы сообщить об изменении состояния объекта. Сигнал может нести информацию о произошедшем изменении.
- **Слот** - это специальная функция, вызываемая в ответ на определенный сигнал. Поскольку слоты - это функции, они содержат логику для выполнения определенного действия.
```cpp
class MyClass : public QObject
{
	Q_OBJECT
public:
	explicit MyClass(QObject *parent = nullptr);
signals:
	void signalName();  // определяем сигнал
public slots:
	void onButtonClicked() { ... }  // определяем слот
};

MyClass::MyClass(QObject *parent = nullptr) : QObject(parent) {
	// соединение сигнала и слота
	QObject::connect(button, SIGNAL(clicked()), this, SLOT(onButtonClicked()));
}

void MyClass::onButtonClicked() {
	// совершение действия
}
```
#### 11. Qt. События и обработчики событий.
**Сигналы** генерируются, когда происходят какие-либо **события**, и всё, что происходит в приложении, является результатом обработки тех или иных событий. Таким событием может быть клик мыши, нажатие клавиши, изменение размера окна, сигнал таймера и т.д.
**В модели событий есть 3 участника**:
1. **Источник события** - это объект, состояние которого изменяется
2. **Объект события** - это отслеживаемый параметр источника события (например, нажатие клавиши на клавиатуре или изменение размеров виджета)
3. **Цель события** - это объект, который должен быть уведомлен о произошедшем событии

В отличие от сигналы, которые необходимы для организации взаимодействия между виджетами, события необходимы для организации взаимодействия между виджетом и системой.
Пример обработки нажатия клавиши:
```cpp
#include <QWidget>
#include <QApplication>
#include <QKeyEvent>

class Window : public QWidget {

public:
	explicit Window(QWidget* parent = 0) : QWidget(parent) { }
	// обработчик события нажатия клавиши
	void keyPressEvent(QKeyEvent* event) {
		if (event->key() == Qt::Key_Escape) {
			qApp->quit(); // закрываем приложение
		}
	}
};
```
Пример обработки сигнала таймера:
```cpp
#include <QWindet>

class MainWindow : public QWidget
{
	Q_OBJECT
public:
	explicit MainWindow(QWidget* parent = 0) : QWidget(parent)
	{
		timerId = startTimer(1000); // запускаем таймер с интервалом 1000 мс
	}
	virtual ~MainWindow();

private:
	int timerId;

protected:
	void timerEvent(QTimerEvent* event);
};

void MainWindow::timerEvent(QTimerEvent* event)
{
	// обрабатываем срабатывание таймера
}

MainWindow::~MainWindow()
{
	killTimer(timerId); // останавливаем таймер в конце
}
```
#### 12. Полиморфное наследование. Сложный полиморфизм. Пример.
Полиморфизм в языке C++ позволяет работать с разными данными одинаковым образом. Несколько классов наследуют и переопределяют свойства одного общего, в результате чего получают общий интерфейс для работы с ними. В зависимости от способа переопределения происходит раннее или позднее связывание методов с объектами и типами, для которых они будут вызваны. Сложный полиморфизм реализуется через механизм позднего связывания и требует описания виртуальных функций. Виртуальными называются функции, которые объявляются с использованием ключевого слова virtual в базовом классе и переопределяются (замещаются) в одном или нескольких производных классах.
```cpp
class Animal {
public:
	virtual void Sound()=0; // чистая виртуальная функция, требуется переопределение в потомках
};

class Dog : public Animal {
public:
	void Sound() override {
		std::cout  << "Ruff-ruff\n";
	}
};

class Cat : public Animal {
public:
	void Sound() override {
		std::cout << "Meow-meow\n";
	}
};

int main() {
	Animal *animals[2];
	animals[0] = new Cat();
	animals[1] = new Dog();
	for (auto i : animals)
		i->Sound();	// для каждого объекта вызовется свой метод
}
```
#### 13. С++. Множественное наследование. Виртуальное наследование. Пример.
Множественным наследованием называется наследование одновременно от нескольких классов, производный класс включает несколько базовых классов. При это необходимо вызывать конструкторы базовых классов с параметрами (при отсутствии конструктора без параметров).
```cpp
#include <iostream>
class Book {   // класс книги
public:
	Book(unsigned pages) : pages(pages) {}
	void printPageCount() {
		std::cout << pages << " pages" << std::endl;
	}
private:
	unsigned pages; // количество страниц
};

class File {   // класс электронного файла
public:
	File(double size) : size(size) {
		std::cout << "File created" << std::endl;
	}
	~File() {
		std::cout << "File deleted" << std::endl;
	}
	void printSize() {
		std::cout << size << "Mb" << std::endl;
	}
private:
	double size;  // размер файла
};
// класс электронной книги
class Ebook : public Book, public File
{
public:
	// нужно вызвать конструкторы базовых классов
	Ebook(std::string title, unsigned pages, double size) :
		Book(pages), File(size), title(title) { }
	void printTitle() {
		std::cout << "Title: " << title << std::endl;
	}
private:
	std::string title;  // название книги
};

int main() {
	Ebook cppbook{ "About C++", 320, 5.6 };
	cppbook.printTitle();
	cppbook.printPageCount();
	cppbook.printSize();
}
```
Если бы базовые классы имели методы с одинаковыми названиями, то произошла бы ошибка компиляции. В таком случае необходимо явно указывать, к методу какого из базовых классов нужно обратиться. Например, если бы в предыдущем примере, классы `Book` и `File` имели метод с названием `print()`, то при обращении к ним требовалось бы явно указать, какой именно вызвать:
```cpp
int main() {
	...
	cppbook.Book::print(); // вызов метода класса Book
	cppbook.File::print(); // вызов метода класса File
}
```
Виртуальное наследование требуется, когда класс наследуется от нескольких классов, которые в свою очередь напрямую или косвенно наследуются от одного базового класса. Например:
```cpp
class Person {
public:
	Person(std::string name) : name(name) {
		std::cout << "Person created" << std::endl;
	}
	~Person() {
		std::cout << "Person deleted" << std::endl;
	}
	void print() const {
		std::cout << "Person " << name << std::endl;
	}
private:
	std::string name;
};

class Student : public virtual Person {
public:
	Student(std::string name) : Person{ name } {}
};

class Employee : public virtual Person {
public:
	Employee(std::string name) : Person{ name } {}
};
// работающий студент
class StudentEmployee : public Student, public Employee {
public:
	StudentEmployee(std::string name) : Person{ name }, Student{ name }, Employee{ name } {}
};

int main() {
	StudentEmployee bob{ "Bob" };
	bob.print();
}
```
Здесь классы `Student` и `Employee` виртуально наследуются от класса `Person`, чтобы их общий наследник `StudentEmployee` мог вызывать функцию `print()`, реализованную в классе `Person`. Если не использовать виртуальное наследование, возникнет ошибка компиляции.
#### 14. С++. Статические поля и методы. Пример.
Статические поля и методы применяют для данных и функций, которые должны относиться не к конкретному объекту класса, а ко всему классу в целом. Для их определения используется ключевое слово `static`. Обращение к таким полям и методам происходит через название класса с помощью двойного двоеточия, например: `Counter::count`.
Статические переменные определяются всего один раз и существует, даже если не было создано ни одного объекта класса. Типичный пример использования статических полей класс - счётчик количества созданных объектов данного класса:
```cpp
class Counter {
private:
	static int count;
public:
	Counter() {
		count++;
	}
	void print_count() {
		std::cout << count << std::endl;
	}
	~Counter() {
		count--;
	}
};

int Counter::count = 0;

int main() {
	Counter *a = new Counter();
	a->print_count();
	Counter b;
	b.print_count();
	delete a;
	b.print_count();
}
```
В этом примере значение переменной `count` общее для объектов `a` и `b`, и, когда объект `a` уничтожается и в его деструкторе значение `count` уменьшается, для объекта `b` это значение также уменьшается.
Статические функции также принадлежат классу и не привязаны к конкретному объекту. Статическими принято делать функции, которые не используют и не изменяют данные конкретного объекта. Можно изменить предыдущий пример, сделав метод для вывода текущего значения счётчика статическим, чтобы он не был привязан к объекту:
```cpp
class Counter {
private:
	static int count;
public:
	Counter() {
		count++;
	}
	static void print_count() {
		std::cout << count << std::endl;
	}
	~Counter() {
		count--;
	}
};

int Counter::count = 0;

int main() {
	Counter::print_count(); // теперь можно вывести count даже до создания первого объекта
	Counter *a = new Counter();
	Counter::print_count();
	Counter b;
	Counter::print_count();
	delete a;
	Counter::print_count();
}
```
#### 15. С++. Переопределение операций. Пример.
Перегрузка операторов (operator overloading) позволяет определить для объектов классов вcтроенные операторы, такие как +, -, * и т.д. Для определения оператора для объектов своего класса, необходимо определить функцию, название которой содержит слово operator и символ перегружаемого оператора. Перегрузить можно только те операторы, которые уже определены в C++. Создать новые операторы нельзя. Также нельзя изменить количество операндов, их ассоциативность, приоритет.
Переопределены операторы могут быть как внутри класса в виде метода (количество параметров на один меньше количества операндов, так как есть доступ к объекту, для которого оператор был вызван), так и в виде отдельной функции вне класса (количество параметров равно количеству операндов). Операторы с двумя параметрами называются бинарными, с одним - унарными.
```cpp
#include <iostream>

class Container {
private:
	int val;
public:
	Container() : val(0) {};
	Container(int v) : val(v) {};
	int get_val() const {
		return val;
	}
	// переопределение оператора сложения внутри класса
	Container operator+(const Container& right) {
		return Container(val + right.get_val());
	}
	//переопределение унарного оператора внутри класса (префиксный инкремент, для постфиксного указать "operator++(int)")
	Container& operator++() {
		val++;
		return *this;
	}
};

// переопределение оператора умножения вне класса
Container operator*(const Container& left, const Container& right) {
	return Container(left.get_val() * right.get_val());
}
// переопределение унарного оператора вне класса
Container& operator--(Container& obj) {
	// в данном случае не получится реализовать оператор, не создавая нового метода в классе и не изменяя доступность полей
	// решить эту проблему можно с помощью дружественных классов (о них следующий вопрос)
	// obj.val--;
	return obj;
}

// переопределение оператора вывода
std::ostream& operator<<(std::ostream& stream, const Container& obj) {
	stream << obj.get_val();
	return stream;
}

int main() {
	Container a(2), b(5);
	std::cout << "Результат сложения: "  << a + b << std::endl;
	std::cout << "Результат умножения: " << a * b << std::endl;
	++a;
	// a++; - сейчас так сделать нельзя, так как не определён этот оператор
	std::cout << "Результат инкремента: " << a << std::endl;
}
```
#### 16. С++. Дружественные функции, методы и классы. Пример.
Дружественные функции и классы могут получать доступ к скрытым полям и методам класса, при этом не являясь членами класса. Для их определения используется ключевое слово `friend`. Модифицируем программу из предыдущего вопроса, переопределение операции декремента вне класса реализовано в виде дружественной функции и теперь может изменять значение `private` поля класса `Container`, хотя не является его членом:
```cpp
class Container {
private:
	int val;
public:
	Container() : val(0) {};
	Container(int v) : val(v) {};
	int get_val() const {
		return val;
	}
	friend Container& operator--(Container& obj);
};

// переопределение унарного оператора вне класса
Container& operator--(Container& obj) {
	obj.val--; // в дружественой функции можем получить доступ к скрытым полям класса
	return obj;
}

int main() {
	Container a(2);
	--a;
	std::cout << "Результат декремента: " << a.get_val() << std::endl;
}
```
Дружественные функции могут также быть методами другого класса, тогда их определение происходит в виде `friend <тип> <имя класса>::<имя метода>(...);`
Дружественными могут быть не только функции, но и целые классы, тогда все методы дружественного класса получат доступ к скрыты полям данного класса:
```cpp
#include <iostream>

class Container {
private:
	int val;
public:
	Container() : val(0) {};
	Container(int v) : val(v) {};
	int get_val() const {
		return val;
	}
	// объявление класса дружественным
	friend class Controller;
};

class Controller {
public:
	// метод дружественного класса получает доступ к скрытым полям
	static void increase(Container& obj) {
		obj.val++;
	}
};

int main() {
	Container a(2);
	std::cout << a.get_val() << std::endl;
	Controller::increase(a);
	std::cout << a.get_val() << std::endl;
}
```
#### 17. С++. Конструкторы перемещения и операция перемещения. Пример.

#### 18. С++. Правило пяти. Пример.
#### 19. С++. Шаблоны функций. Пример.
#### 20. С++. Шаблоны классов. Пример.
#### 21. С++. Организация контейнеров на шаблонах. Пример диаграммы классов.
#### 22. С++. Шаблоны стандартных классов. Пример.
#### 23. С++. Исключения С++. Пример.
#### 24. С++. Умные указатели. Особенности использования. Пример.
#### 25. С++. Стандартные умные указатели. Отличия.
# C\#
#### 1. С#. Платформа .NET. Процесс выполнения программы.
#### 2. С#. Структура программы. Пространство имен. Сборка.
#### 3. С#. Типы данных. Различия типов-значений и типов-ссылок.
#### 4. С#. Литералы. Примеры. Переменные. Примеры. Область действия переменной.
#### 5. С#. Выражения. Преобразование типов при выполнении операций. Примеры.
#### 6. С#. Ввод-вывод консольного приложения. Примеры.
#### 7. С#. Исключения. Примеры.
#### 8. С#. Объявление классов и их компонентов. Примеры.
#### 9. С#. Спецификации доступа классов, структур и их компонентов.
#### 10. C#. Конструкторы классов. Примеры.
#### 11. C#. Поля: константные, объекта, класса, только для чтения. Примеры.
#### 12. C#. Методы: конструкторы объектов, статические, деструкторы. Примеры.
#### 13. C#. Методы: объектов, классов. Примеры.
#### 14. C#. Параметры методов. Передача параметров по значению и по ссылке. Выходные параметры. Примеры.
#### 15. C#. Одномерные массивы c элементами типов-значений и ссылочных типов. Примеры объявления.
#### 16. C#. Оператор foreach. Примеры применения для массивов разных типов.
#### 17. C#. Массивы прямоугольные и ступенчатые. Различие. Примеры
#### 18. C#. Строка String. Примеры создания и использования.
#### 19. C#. Регулярные выражения. Примеры.
#### 20. C#. Структуры. Примеры.
#### 21. C#. Наследование. Пример.
#### 22. C#. Полиморфное наследование. Абстрактные классы. Пример.
#### 23. C#. Композиция и агрегация. Пример.
#### 24. C#. Интерфейсы. Пример.
#### 25. C#. Свойства. Пример.